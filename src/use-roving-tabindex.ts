import React from "react";
import { RovingTabIndexContext, ActionTypes } from "./Provider";
import uniqueId from "lodash.uniqueid";

type ReturnType = [
  number,
  boolean,
  (event: React.KeyboardEvent<any>) => void,
  () => void
];

// domElementRef:
//   - a React DOM element ref of the DOM element that is the focus target
//   - this must be the same DOM element for the lifecycle of the component
// disabled:
//   - can be updated as appropriate to reflect the current enabled or disabled
//     state of the component
// id:
//   - an optional ID that is the unique ID for the component
//   - if provided then it must be a non-empty string
//   - if not provided then one will be autogenerated
// The returned callbacks handleKeyDown and handleClick are stable.
export default function useRovingTabIndex(
  domElementRef: React.RefObject<any>,
  disabled: boolean,
  isGrid?: boolean,
  id?: string
): ReturnType {
  // This id is stable for the life of the component:
  const tabIndexId = React.useRef(id || uniqueId("roving-tabindex_"));
  const context = React.useContext(RovingTabIndexContext);

  // Registering and unregistering are tied to whether the input is disabled or not.
  // Context is not in the inputs because context.dispatch is stable.
  React.useLayoutEffect(() => {
    if (disabled) {
      return;
    }
    context.dispatch({
      type: ActionTypes.REGISTER,
      payload: { id: tabIndexId.current, domElementRef }
    });
    return () => {
      context.dispatch({
        type: ActionTypes.UNREGISTER,
        payload: { id: tabIndexId.current }
      });
    };
  }, [disabled]);
  
  const handleKeyDown = React.useCallback((event: React.KeyboardEvent<any>) => {
    // when it is not a grid, both arrows should move focus backwards
    if (event.key === "ArrowLeft" || (!isGrid && event.key === "ArrowUp")) {
      context.dispatch({
        type: ActionTypes.TAB_TO_PREVIOUS,
        payload: { id: tabIndexId.current }
      });
      event.preventDefault();
      // when it is not a grid, both arrows should move focus forward
    } else if (event.key === "ArrowRight" || (!isGrid && event.key === "ArrowDown")) {
      context.dispatch({
        type: ActionTypes.TAB_TO_NEXT,
        payload: { id: tabIndexId.current }
      });
      event.preventDefault();
      // in a grid, should move focus to previous row
    } else if (event.key === "ArrowUp") {
      context.dispatch({
        type: ActionTypes.TAB_TO_PREVIOUS_ROW,
        payload: { id: tabIndexId.current }
      });
      event.preventDefault();
      // in a grid, should move focus to next row
    } else if (event.key === "ArrowDown") {
      context.dispatch({
        type: ActionTypes.TAB_TO_NEXT_ROW,
        payload: { id: tabIndexId.current }
      });
      event.preventDefault();
      // should move focus to initial element 
    } else if (event.key === "Home") {
      context.dispatch({
        type: ActionTypes.TAB_TO_FIRST,
        payload: { id: tabIndexId.current }
      });
      event.preventDefault();
      // should move focus to last element
    } else if (event.key === "End") {
      context.dispatch({
        type: ActionTypes.TAB_TO_LAST,
        payload: { id: tabIndexId.current }
      });
      event.preventDefault();
    } 
  }, [isGrid]);

  const handleClick = React.useCallback(() => {
    context.dispatch({
      type: ActionTypes.CLICKED,
      payload: { id: tabIndexId.current }
    });
  }, []);

  const selected = !disabled && tabIndexId.current === context.state.selectedId;
  const tabIndex = selected ? 0 : -1;
  const focused = selected && context.state.lastActionOrigin === "keyboard";
  return [tabIndex, focused, handleKeyDown, handleClick];
}
